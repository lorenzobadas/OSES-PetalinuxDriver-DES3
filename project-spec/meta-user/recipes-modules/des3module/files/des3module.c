/*  des3module.c - The simplest kernel module.

* Copyright (C) 2013-2022 Xilinx, Inc
* Copyright (c) 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
*
*   This program is free software; you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation; either version 2 of the License, or
*   (at your option) any later version.

*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License along
*   with this program. If not, see <http://www.gnu.org/licenses/>.

*/
#include <linux/atomic.h> 
#include <linux/cdev.h> 
#include <linux/delay.h> 
#include <linux/device.h> 
#include <linux/fs.h> 
#include <linux/init.h>
#include <linux/printk.h> 
#include <linux/types.h> 
#include <linux/uaccess.h> /* for get_user and put_user */ 
#include <linux/version.h> 

#include <asm/errno.h> 

#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/io.h>
#include <linux/interrupt.h>

#define DRIVER_FILE_NAME "des3module"
#define DEVICE_PATH "/dev/des3module"
#define MAJOR_NUM 100
#define XPAR_DES3_AXI_0_S00_AXI_BASEADDR 0x43C00000
#define XPAR_DES3_AXI_0_S00_AXI_HIGHADDR 0x43C0FFFF
#define DES3_AXI_DES_IN_HI_OFFSET 0
#define DES3_AXI_DES_IN_LO_OFFSET 4
#define DES3_AXI_KEY1_HI_OFFSET 8
#define DES3_AXI_KEY1_LO_OFFSET 12
#define DES3_AXI_KEY2_HI_OFFSET 16
#define DES3_AXI_KEY2_LO_OFFSET 20
#define DES3_AXI_KEY3_HI_OFFSET 24
#define DES3_AXI_KEY3_LO_OFFSET 28
#define DES3_AXI_DECRYPT_OFFSET 32
#define DES3_AXI_DES_OUT_LO_OFFSET 36
#define DES3_AXI_DES_OUT_HI_OFFSET 40
#define DES3_AXI_READY_OFFSET 44
#define DES3_AXI_VALID_KEY_OFFSET 48
#define SUCCESS 0
#define DATA_SIZE 8

/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR
    ("Xilinx Inc.");
MODULE_DESCRIPTION
    ("des3module - loadable module template generated by petalinux-create -t modules");

static void __iomem* axi_slv_regs;
static struct class *cls;

/* This is called whenever a process attempts to open the device file */ 
static int device_open(struct inode *inode, struct file *file) 
{ 
    pr_info("device_open(%p)\n", file); 
 
    try_module_get(THIS_MODULE); 
    return SUCCESS; 
} 

static int device_release(struct inode *inode, struct file *file) 
{ 
    pr_info("device_release(%p,%p)\n", inode, file); 
 
    module_put(THIS_MODULE); 
    return SUCCESS;
}

/* This function is called whenever a process which has already opened the 
 * device file attempts to read from it. 
 */ 
static ssize_t device_read(struct file *file, /* see include/linux/fs.h   */ 
                           char __user *buffer, /* buffer to be filled  */ 
                           size_t length, /* length of the buffer     */ 
                           loff_t *offset)
{ 	
	int i;
	unsigned int result[13];
	pr_info("Starting read from AXI Registers\n");
	result[ 0] = ioread32(axi_slv_regs + DES3_AXI_DES_IN_HI_OFFSET);
	result[ 1] = ioread32(axi_slv_regs + DES3_AXI_DES_IN_LO_OFFSET);
	result[ 2] = ioread32(axi_slv_regs + DES3_AXI_KEY1_HI_OFFSET);
	result[ 3] = ioread32(axi_slv_regs + DES3_AXI_KEY1_LO_OFFSET);
	result[ 4] = ioread32(axi_slv_regs + DES3_AXI_KEY2_HI_OFFSET);
	result[ 5] = ioread32(axi_slv_regs + DES3_AXI_KEY2_LO_OFFSET);
	result[ 6] = ioread32(axi_slv_regs + DES3_AXI_KEY3_HI_OFFSET);
	result[ 7] = ioread32(axi_slv_regs + DES3_AXI_KEY3_LO_OFFSET);
	result[ 8] = ioread32(axi_slv_regs + DES3_AXI_DECRYPT_OFFSET);
	result[ 9] = ioread32(axi_slv_regs + DES3_AXI_DES_OUT_HI_OFFSET);
	result[10] = ioread32(axi_slv_regs + DES3_AXI_DES_OUT_LO_OFFSET);
	result[11] = ioread32(axi_slv_regs + DES3_AXI_READY_OFFSET);
	result[12] = ioread32(axi_slv_regs + DES3_AXI_VALID_KEY_OFFSET);

	pr_info("Read from AXI Registers completed\n");
	pr_info("des_in  : 0x%08X%08X\n", result[0], result[1]);
	pr_info("decrypt : 0x%08X\n", 	  result[8]);
	pr_info("key1    : 0x%08X%08X\n", result[2], result[3]);
	pr_info("key2    : 0x%08X%08X\n", result[4], result[5]);
	pr_info("key3    : 0x%08X%08X\n", result[6], result[7]);
	pr_info("des_out : 0x%08X%08X\n", result[9], result[10]);
	pr_info("ready   : 0x%08X\n", 	  result[11]);
	pr_info("validkey: 0x%08X\n\n",   result[12]);


	// checks
	if (length < 52) {
		pr_info("lenght is %d\n", length);
		pr_alert("length < 52\n Nothing done\n");
		return 0;
	}

	copy_to_user(buffer, result, sizeof(result));

	pr_info("Read 52 bytes\n"); 
	return 52;
}

/* called when somebody tries to write into our device file. */ 
static ssize_t device_write(struct file *file, const char __user *buffer, 
                            size_t length, loff_t *offset) 
{   
	char kernel_buffer[36] = {0};

	// checks
	if (length != 36) {
		pr_info("lenght is %d\n", length);
		pr_alert("Tried to write length != 36\nNothing done\n");
		return 0;
	}
	if (*offset != 0) {
		pr_info("Offset != 0\nOffset was ignored\n");
	}

	// write operation
    for (int i = 0; i < length; i++) {
		get_user(kernel_buffer[i], buffer + i); 
	}
	pr_info("Starting write to AXI Registers\n");
	iowrite32(*((unsigned int*)(kernel_buffer   )), axi_slv_regs + DES3_AXI_KEY1_HI_OFFSET);
	iowrite32(*((unsigned int*)(kernel_buffer+ 4)), axi_slv_regs + DES3_AXI_KEY1_LO_OFFSET);
	iowrite32(*((unsigned int*)(kernel_buffer+ 8)), axi_slv_regs + DES3_AXI_KEY2_HI_OFFSET);
	iowrite32(*((unsigned int*)(kernel_buffer+12)), axi_slv_regs + DES3_AXI_KEY2_LO_OFFSET);
	iowrite32(*((unsigned int*)(kernel_buffer+16)), axi_slv_regs + DES3_AXI_KEY3_HI_OFFSET);
	iowrite32(*((unsigned int*)(kernel_buffer+20)), axi_slv_regs + DES3_AXI_KEY3_LO_OFFSET);
	iowrite32(*((unsigned int*)(kernel_buffer+24)), axi_slv_regs + DES3_AXI_DES_IN_HI_OFFSET);
	iowrite32(*((unsigned int*)(kernel_buffer+28)), axi_slv_regs + DES3_AXI_DES_IN_LO_OFFSET);
	iowrite32(*((unsigned int*)(kernel_buffer+32)), axi_slv_regs + DES3_AXI_DECRYPT_OFFSET);
	pr_info("Write to AXI Registers completed\n");
    /* Return the number of input characters used. */ 
    return 36; 
} 

/* This structure will hold the functions to be called when a process does 
 * something to the device we created. Since a pointer to this structure 
 * is kept in the devices table, it can't be local to init_module. NULL is 
 * for unimplemented functions. 
 */ 
static struct file_operations fops = { 
    .read = device_read,
    .write = device_write,
    .open = device_open, 
    .release = device_release, /* a.k.a. close */ 
}; 

static int __init des3module_init(void)
{
    int major = register_chrdev(0, DRIVER_FILE_NAME, &fops); 
 
    if (major < 0) { 
        pr_alert("Registering char device failed with %d\n", major); 
        return major; 
    } 
    pr_info("Char device was assigned major number %d.\n", major); 
 
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0) 
    cls = class_create(DRIVER_FILE_NAME); 
#else 
    cls = class_create(THIS_MODULE, DRIVER_FILE_NAME); 
#endif 
    device_create(cls, NULL, MKDEV(major, 0), NULL, DRIVER_FILE_NAME); 
    pr_info("Device created on /dev/%s\n", DRIVER_FILE_NAME); 

    if (!request_mem_region(XPAR_DES3_AXI_0_S00_AXI_BASEADDR, 52, DRIVER_FILE_NAME)) {
		pr_info("Couldn't lock memory region at 0x%x\n",
			XPAR_DES3_AXI_0_S00_AXI_BASEADDR);
		return -EBUSY;
	}
	axi_slv_regs = ioremap(XPAR_DES3_AXI_0_S00_AXI_BASEADDR, XPAR_DES3_AXI_0_S00_AXI_HIGHADDR - XPAR_DES3_AXI_0_S00_AXI_BASEADDR + 1);
	if (!axi_slv_regs) {
		printk(KERN_INFO "failed to map axi base address\n");
		return -ENOMEM;
	}
	pr_info("Successfully remapped axi_slv_regs from 0x%x to 0x%p", XPAR_DES3_AXI_0_S00_AXI_BASEADDR, axi_slv_regs);

    return SUCCESS; 
} 

static void __exit des3module_exit(void)
{
	iounmap(axi_slv_regs);
	device_destroy(cls, MKDEV(MAJOR_NUM, 0)); 
    class_destroy(cls); 
    /* Unregister the device */ 
    unregister_chrdev(MAJOR_NUM, DRIVER_FILE_NAME);

	printk(KERN_ALERT "Goodbye module world.\n");
}

module_init(des3module_init);
module_exit(des3module_exit);
